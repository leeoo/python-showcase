出版者的话.
译者序
前言
第1章 引论1
	1.1 什么是操作系统2
		1.1.1 作为扩展机器的操作系统2
		1.1.2 作为资源管理者的操作系统3
		1.2 操作系统的历史4
		1.2.1 第一代（1945～1955）：真空管和穿孔卡片4
		1.2.2 第二代（1955～1965）：晶体管和批处理系统4
		1.2.3 第三代（1965～1980）：集成电路芯片和多道程序设计6
		1.2.4 第四代（1980年至今）：个人计算机8
		1.3 计算机硬件介绍10
		1.3.1 处理器11
		1.3.2 存储器12
		1.3.3 磁盘14
		1.3.4 磁带15
		1.3.5 I/O设备15
		1.3.6 总线17
		1.3.7 启动计算机18
	1.4 操作系统大观园19
		1.4.1 大型机操作系统19
		1.4.2 服务器操作系统19
		1.4.3 多处理器操作系统19
		1.4.4 个人计算机操作系统19
		1.4.5 掌上计算机操作系统19
		1.4.6 嵌入式操作系统20
		1.4.7 传感器节点操作系统20
		1.4.8 实时操作系统20
		1.4.9 智能卡操作系统20
	1.5 操作系统概念21
		1.5.1 进程21
		1.5.2 地址空间22
		1.5.3 文件22
		1.5.4 输入/输出24
		1.5.5 保护24
		1.5.6 Shell 24
		1.5.7 个体重复系统发育25
	1.6 系统调用27
		1.6.1 用于进程管理的系统调用30
		1.6.2 用于文件管理的系统调用31
		1.6.3 用于目录管理的系统调用31
		1.6.4 各种系统调用33
		1.6.5 Windows Win32 API 33
	1.7 操作系统结构34
		1.7.1 单体系统34
		1.7.2 层次式系统35
		1.7.3 微内核36
		1.7.4 客户机-服务器模式37
		1.7.5 虚拟机38
		1.7.6 外核40
	1.8 依靠C的世界40
		1.8.1 C语言40
		1.8.2 头文件41
		1.8.3 大型编程项目41
		1.8.4 运行模型42
	1.9 有关操作系统的研究42
	1.10 本书其他部分概要43
	1.11 公制单位43
	1.12 小结44
	习题44
第2章 进程与线程47
	2.1 进程47
		2.1.1 进程模型47
		2.1.2 创建进程48
		2.1.3 进程的终止49
		2.1.4 进程的层次结构50
		2.1.5 进程的状态50
		2.1.6 进程的实现51
		2.1.7 多道程序设计模型52
	2.2 线程53
		2.2.1 线程的使用53
		2.2.2 经典的线程模型56
		2.2.3 POSIX线程59
		2.2.4 在用户空间中实现线程59
		2.2.5 在内核中实现线程62
		2.2.6 混合实现62
		2.2.7 调度程序激活机制63
		2.2.8 弹出式线程63
		2.2.9 使单线程代码多线程化64
	2.3 进程间通信66
		2.3.1 竞争条件66
		2.3.2 临界区67
		2.3.3 忙等待的互斥67
		2.3.4 睡眠与唤醒70
		2.3.5 信号量72
		2.3.6 互斥量74
		2.3.7 管程76
		2.3.8 消息传递80
		2.3.9 屏障81
	2.4 调度82
		2.4.1 调度介绍82
		2.4.2 批处理系统中的调度85
		2.4.3 交互式系统中的调度87
		2.4.4 实时系统中的调度90
		2.4.5 策略和机制90
		2.4.6 线程调度91
	2.5 经典的IPC问题92
		2.5.1 哲学家就餐问题92
		2.5.2 读者一写者问题94
	2.6 有关进程和线程的研究95
	2.7 小结95
	习题95
第3章 存储管理99
	3.1 无存储器抽象99
	3.2 一种存储器抽象：地址空间101
		3.2.1 地址空间的概念101
		3.2.2 交换技术103
		3.2.3 空闲内存管理104
	3.3 虚拟内存106
		3.3.1 分页107
		3.3.2 页表108
		3.3.3 加速分页过程109
		3.3.4 针对大内存的页表111
	3.4 页面置换算法113
		3.4.1 最优页面置换算法114
		3.4.2 最近未使用页面置换算法114
		3.4.3 先进先出页面置换算法115
		3.4.4 第二次机会页面置换算法115
		3.4.5 时钟页面置换算法116
		3.4.6 最近最少使用页面置换算法116
		3.4.7 用软件模拟LRU 117
		3.4.8 工作集页面置换算法118
		3.4.9 工作集时钟页面置换算法120
		3.4.10 页面置换算法小结121
	3.5 分页系统中的设计问题121
		3.5.1 局部分配策略与全局分配策略121
		3.5.2 负载控制123
		3.5.3 页面大小123
		3.5.4 分离的指令空间和数据空间124
		3.5.5 共享页面124
		3.5.6 共享库125
		3.5.7 内存映射文件126
		3.5.8 清除策略127
		3.5.9 虚拟内存接口127
	3.6 有关实现的问题128
		3.6.1 与分页有关的工作128
		3.6.2 缺页中断处理128
		3.6.3 指令备份129
		3.6.4 锁定内存中的页面129
		3.6.5 后备存储129
		3.6.6 策略和机制的分离130
	3.7 分段131
		3.7.1 纯分段的实现133
		3.7.2 分段和分页结合：MULTICS 134
		3.7.3 分段和分页结合：Intel Pentium 135
	3.8 有关存储管理的研究138
	3.9 小结138
	习题139
第4章 文件系统143
	4.1 文件144
		4.1.1 文件命名144
		4.1.2 文件结构145
		4.1.3 文件类型145
		4.1.4 文件存取147
		4.1.5 文件属性147
		4.1.6 文件操作148
		4.1.7 使用文件系统调用的一个示例程序148
	4.2 目录150
		4.2.1 一级目录系统150
		4.2.2 层次目录系统150
		4.2.3 路径名150
		4.2.4 目录操作152
	4.3 文件系统的实现153
		4.3.1 文件系统布局153
		4.3.2 文件的实现153
		4.3.3 目录的实现156
		4.3.4 共享文件158
		4.3.5 日志结构文件系统159
		4.3.6 日志文件系统160
		4.3.7 虚拟文件系统161
	4.4 文件系统管理和优化163
		4.4.1 磁盘空间管理163
		4.4.2 文件系统备份167
		4.4.3 文件系统的一致性170
		4.4.4 文件系统性能172
		4.4.5 磁盘碎片整理174
	4.5 文件系统实例175
		4.5.1 CD-ROM文件系统175
		4.5.2 MS-DOS文件系统178
		4.5.3 Unix v7文件系统179
	4.6 有关文件系统的研究181
	4.7 小结181
	习题182
第5章 输入/输出184
	5.1 I/O硬件原理184
		5.1.1 I/O设备184
		5.1.2 设备控制器185
		5.1.3 内存映射I/O 185
		5.1.4 直接存储器存取187
		5.1.5 重温中断189
	5.2 I/O软件原理191
		5.2.1 I/O软件的目标191
		5.2.2 程序控制I/O 192
		5.2.3 中断驱动I/O 193
		5.2.4 使用DMA的I/O194
	5.3 I/O软件层次194
		5.3.1 中断处理程序194
		5.3.2 设备驱动程序195
		5.3.3 与设备无关的I/O软件197
		5.3.4 用户空间的I/O软件200
	5.4 盘201
		5.4.1 盘的硬件201
		5.4.2 磁盘格式化211
		5.4.3 磁盘臂调度算法212
		5.4.4 错误处理214
		5.4.5 稳定存储器216
	5.5 时钟218
		5.5.1 时钟硬件218
		5.5.2 时钟软件219
		5.5.3 软定时器220
	5.6 用户界面：键盘、鼠标和监视器221
		5.6.1 输入软件221
		5.6.2 输出软件224
	5.7 瘦客户机233
	5.8 电源管理235
		5.8.1 硬件问题235
		5.8.2 操作系统问题236
		5.8.3 应用程序问题239
	5.9 有关输入/输出的研究239
	5.10 小结240
	习题241
第6章 死锁244
	6.1 资源244
		6.1.1 可抢占资源和不可抢占资源244
		6.1.2 资源获取245
	6.2 死锁概述246
		6.2.1 资源死锁的条件246
		6.2.2 死锁建模246
	6.3 鸵鸟算法248
	6.4 死锁检测和死锁恢复248
		6.4.1 每种类型一个资源的死锁检测249
		6.4.2 每种类型多个资源的死锁检测250
		6.4.3 从死锁中恢复251
	6.5 死锁避免252
		6.5.1 资源轨迹图252
		6.5.2 安全状态和不安全状态253
		6.5.3 单个资源的银行家算法254
		6.5.4 多个资源的银行家算法254
	6.6 死锁预防255
		6.6.1 破坏互斥条件255
		6.6.2 破坏占有和等待条件256
		6.6.3 破坏不可抢占条件256
		6.6.4 破坏环路等待条件256
	6.7 其他问题257
		6.7.1 两阶段加锁257
		6.7.2 通信死锁257
		6.7.3 活锁258
		6.7.4 饥饿259
	6.8 有关死锁的研究259
	6.9 小结259
	习题260
第7章 多媒体操作系统263
	7.1 多媒体简介263
	7.2 多媒体文件..266
		7.2.1 视频编码266
		7.2.2 音频编码268
	7.3 视频压缩269
		7.3.1 JPEG标准269
		7.3.2 MPEG标准271
	7.4 音频压缩272
	7.5 多媒体进程调度274
		7.5.1 调度同质进程275
		7.5.2 一般实时调度275
		7.5.3 速率单调调度276
		7.5.4 最早最终时限优先调度277
	7.6 多媒体文件系统范型278
		7.6.1 VCR控制功能279
		7.6.2 近似视频点播279
		7.6.3 具有VCR功能的近似视频点播281
	7.7 文件存放282
		7.7.1 在单个磁盘上存放文件282
		7.7.2 两个替代的文件组织策略282
		7.7.3 近似视频点播的文件存放284
		7.7.4 在单个磁盘上存放多个文件285
		7.7.5 在多个磁盘上存放文件287
	7.8 高速缓存288
		7.8.1 块高速缓存288
		7.8.2 文件高速缓存289
	7.9 多媒体磁盘调度290
		7.9.1 静态磁盘调度290
		7.9.2 动态磁盘调度291
	7.10 有关多媒体的研究292
	7.11 小结292
	习题293
第8章 多处理机系统295
	8.1 多处理机296
		8.1.1 多处理机硬件296
		8.1.2 多处理机操作系统类型301
		8.1.3 多处理机同步303
		8.1.4 多处理机调度306
	8.2 多计算机309
		8.2.1 多计算机硬件309
		8.2.2 低层通信软件312
		8.2.3 用户层通信软件313
		8.2.4 远程过程调用314
		8.2.5 分布式共享存储器316
		8.2.6 多计算机调度319
		8.2.7 负载平衡319
	8.3 虚拟化321
		8.3.1 虚拟化的条件322
		8.3.2 I型管理程序322
		8.3.3 II型管理程序323
		8.3.4 准虚拟化324
		8.3.5 内存的虚拟化325
		8.3.6 I/O设备的虚拟化326
		8.3.7 虚拟工具327
		8.3.8 多核处理机上的虚拟机327
		8.3.9 授权问题327
	8.4 分布式系统327
		8.4.1 网络硬件329
		8.4.2 网络服务和协议331
		8.4.3 基于文档的中间件333
		8.4.4 基于文件系统的中间件334
		8.4.5 基于对象的中间件337
		8.4.6 基于协作的中间件338
		8.4.7 网格341
	8.5 有关多处理机系统的研究341
	8.6 小结342
	习题343
第9章 安全346
	9.1 环境安全347
		9.1.1 威胁347
		9.1.2 入侵者347
		9.1.3 数据意外遗失348
	9.2 密码学原理348
		9.2.1 私钥加密技术349
		9.2.2 公钥加密技术349
		9.2.3 单向函数350
		9.2.4 数字签名350
		9.2.5 可信平台模块351
	9.3 保护机制352
		9.3.1 保护域352
		9.3.2 访问控制列表353
		9.3.3 权能354
		9.3.4 可信系统356
		9.3.5 可信计算基357
		9.3.6 安全系统的形式化模型358
		9.3.7 多级安全358
		9.3.8 隐蔽信道360
	9.4 认证362
		9.4.1 使用口令认证363
		9.4.2 使用实际物体的认证方式367
		9.4.3 使用生物识别的验证方式369
	9.5 内部攻击370
		9.5.1 逻辑炸弹370
		9.5.2 后门陷阱370
		9.5.3 登录欺骗371
	9.6 利用代码漏洞371
		9.6.1 缓冲区溢出攻击372
		9.6.2 格式化字符串攻击373
		9.6.3 返回libc攻击374
		9.6.4 整数溢出攻击375
		9.6.5 代码注入攻击376
		9.6.6 权限提升攻击376
	9.7 恶意软件377
		9.7.1 特洛伊木马378
		9.7.2 病毒379
		9.7.3 蠕虫385
		9.7.4 间谍软件386
		9.7.5 rootkit 388
	9.8 防御390
		9.8.1 防火墙391
		9.8.2 反病毒和抑制反病毒技术392
		9.8.3 代码签名395
		9.8.4 囚禁396
		9.8.5 基于模型的入侵检测397
		9.8.6 封装移动代码398
		9.8.7 java安全性400
	9.9 有关安全性研究401
	9.10 小结401
	习题402
第10章 实例研究1：Linux 405
	10.1 Unix与Linux的历史405
		10.1.1 unics 405
		10.1.2 pdp-11 Unix 406
		10.1.3 可移植的Unix 406
		10.1.4 berkeley Unix 407
		10.1.5 标准Unix 407
		10.1.6 minix 408
		10.1.7 Linux 409
	10.2 Linux概述410
		10.2.1 Linux的设计目标410
		10.2.2 到Linux的接口411
		10.2.3 Shell 412
		10.2.4 Linux应用程序413
		10.2.5 内核结构414
	10.3 Linux中的进程416
		10.3.1 基本概念416
		10.3.2 Linux中进程管理相关的系统调用418
		10.3.3 Linux中进程与线程的实现420
		10.3.4 Linux中的调度424
		10.3.5 启动Linux系统426
	10.4 Linux中的内存管理427
		10.4.1 基本概念427
		10.4.2 Linux中的内存管理系统调用429
		10.4.3 Linux中内存管理的实现430
		10.4.4 Linux中的分页434
	10.5 Linux中的I/O系统435
		10.5.1 基本概念435
		10.5.2 网络436
		10.5.3 Linux的输入/输出系统调用437
		10.5.4 输入/输出在Linux中的实现437
		10.5.5 Linux中的模块439
	10.6 Linux文件系统440
		10.6.1 基本概念440
		10.6.2 Linux的文件系统调用442
		10.6.3 Linux文件系统的实现444
		10.6.4 nfs：网络文件系统449
	10.7 Linux的安全性453
		10.7.1 基本概念453
		10.7.2 Linux中安全相关的系统调用454
		10.7.3 Linux中的安全实现455
	10.8 小结455
	习题456
第11章 实例研究2：Windows Vista 459
	11.1 Windows Vista的历史459
		11.1.1 20世纪80年代：MS-DOS 459
		11.1.2 20世纪90年代：基于MS-DOS的Windows 460
		11.1.3 21世纪：基于NT的Windows 460
		11.1.4 Windows Vista 462
	11.2 Windows Vista编程462
		11.2.1 内部NT应用编程接口463
		11.2.2 win32应用编程接口465
		11.2.3 Windows注册表467
	11.3 系统结构468
		11.3.1 操作系统结构469
		11.3.2 启动Windows Vista 476
		11.3.3 对象管理器的实现477
		11.3.4 子系统、dll和用户态服务483
	11.4 Windows Vista中的进程和线程484
		11.4.1 基本概念484
		11.4.2 作业、进程、线程和纤程管理api调用487
		11.4.3 进程和线程的实现490
	11.5 内存管理494
		11.5.1 基本概念494
		11.5.2 内存管理系统调用496
		11.5.3 存储管理的实现497
	11.6 Windows Vista的高速缓存502
	11.7 Windows Vista的输入/输出504
		11.7.1 基本概念504
		11.7.2 输入/输出api调用504
		11.7.3 I/O实现506
	11.8 Windows nt文件系统509
		11.8.1 基本概念510
		11.8.2 NTFS文件系统的实现510
	11.9 Windows Vista中的安全516
		11.9.1 基本概念516
		11.9.2 安全相关的api调用518
		11.9.3 安全性的实现518
	11.10 小结519
	习题520
第12章 实例研究3：Symbian操作系统522
	12.1 Symbian操作系统的历史522
		12.1.1 Symbian操作系统的起源：psion和epoc 522
		12.1.2 Symbian操作系统版本6 523
		12.1.3 Symbian操作系统版本7 523
		12.1.4 今天的Symbian操作系统523
	12.2 Symbian操作系统概述523
		12.2.1 面向对象524
		12.2.2 微内核设计524
		12.2.3 Symbian操作系统纳核525
		12.2.4 客户机/服务器资源访问525
		12.2.5 较大型操作系统的特点525
		12.2.6 通信与多媒体526
	12.3 Symbian操作系统中的进程和线程526
		12.3.1 线程和纳线程526
		12.3.2 进程527
		12.3.3 活动对象527
		12.3.4 进程间通信527
	12.4 内存管理528
		12.4.1 没有虚拟内存的系统528
		12.4.2 Symbian操作系统的寻址方式529
	12.5 输入和输出530
		12.5.1 设备驱动530
		12.5.2 内核扩展530
		12.5.3 直接存储器访问531
		12.5.4 特殊情况：存储介质531
		12.5.5 阻塞I/O 531
		12.5.6 可移动存储器531
	12.6 存储系统532
		12.6.1 移动设备文件系统532
		12.6.2 Symbian操作系统文件系统532
		12.6.3 文件系统安全和保护532
	12.7 Symbian操作系统的安全533
	12.8 Symbian操作系统中的通信534
		12.8.1 基本基础结构534
		12.8.2 更仔细地观察基础结构535
	12.9 小结536
	习题536
第13章 操作系统设计537
	13.1 设计问题的本质537
		13.1.1 目标537
		13.1.2 设计操作系统为什么困难538
	13.2 接口设计539
		13.2.1 指导原则539
		13.2.2 范型540
		13.2.3 系统调用接口542
	13.3 实现543
		13.3.1 系统结构543
		13.3.2 机制与策略545
		13.3.3 正交性546
		13.3.4 命名546
		13.3.5 绑定的时机547
		13.3.6 静态与动态结构547
		13.3.7 自顶向下与自底向上的实现548
		13.3.8 实用技术549
	13.4 性能552
		13.4.1 操作系统为什么运行缓慢552
		13.4.2 什么应该优化552
		13.4.3 空间-时间的权衡553
		13.4.4 高速缓存554
		13.4.5 线索555
		13.4.6 利用局部性555
		13.4.7 优化常见的情况555
	13.5 项目管理556
		13.5.1 人月神话556
		13.5.2 团队结构556
		13.5.3 经验的作用558
		13.5.4 没有银弹558
	13.6 操作系统设计的趋势558
		13.6.1 虚拟化559
		13.6.2 多核芯片559
		13.6.3 大型地址空间操作系统559
		13.6.4 联网559
		13.6.5 并行系统与分布式系统560
		13.6.6 多媒体560
		13.6.7 电池供电的计算机560
		13.6.8 嵌入式系统560
		13.6.9 传感节点561
	13.7 小结561
	习题561
第14章 阅读材料及参考文献563
	14.1 进行深入阅读的建议563
		14.1.1 简介及概要563
		14.1.2 进程和线程563
		14.1.3 存储管理564
		14.1.4 输入/输出564
		14.1.5 文件系统564
		14.1.6 死锁564
		14.1.7 多媒体操作系统564
		14.1.8 多处理机系统565
		14.1.9 安全565
		14.1.10 Linux 566
		14.1.11 Windows Vista 567
		14.1.12 Symbian操作系统567
		14.1.13 设计原则567
	14.2 按字母顺序排序的参考文献...568